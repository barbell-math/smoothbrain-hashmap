<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# sbmap

```go
import "github.com/barbell-math/smoothbrain-hashmap"
```

A very simple library that implements a generic, linear probing map.

<details><summary>Example (Custom Eq And Hash Funcs)</summary>
<p>



```go
seed := maphash.MakeSeed()

h := NewCustom[string, string](
	4,
	func(l, r string) bool { return strings.ToLower(l) == strings.ToLower(r) },
	func(v string) uint64 { return maphash.String(seed, strings.ToLower(v)) },
)
h.Put("one", "one")
h.Put("two", "two")
h.Put("three", "three")
h.Put("ThReE", "four")

if val, ok := h.Get("three"); ok {
	fmt.Println(val)
}

h.Remove("tWO")
fmt.Println(h.Len())

fmt.Println("Keys:")
keys := slices.Collect(h.Keys())
slices.Sort(keys)
fmt.Println(keys)

// Output:
//four
//2
//Keys:
//[one three]
```

#### Output

```
four
2
Keys:
[one three]
```

</p>
</details>

<details><summary>Example (Simple)</summary>
<p>



```go
h := New[int, string]()
h.Put(1, "one")
h.Put(2, "two")
h.Put(3, "three")

if val, ok := h.Get(1); ok {
	fmt.Println(val)
}
if _, ok := h.Get(4); !ok {
	fmt.Println("4 was not in the map!")
}

h.Remove(1)
fmt.Println(h.Len())

fmt.Println("Keys:")
keys := slices.Collect(h.Keys())
slices.Sort(keys)
fmt.Println(keys)

// Output:
//one
//4 was not in the map!
//2
//Keys:
//[2 3]
```

#### Output

```
one
4 was not in the map!
2
Keys:
[2 3]
```

</p>
</details>

## Index

- [func ComparableEqual\[T comparable\]\(l T, r T\) bool](<#ComparableEqual>)
- [func ComparableHash\[T comparable\]\(v T\) uint64](<#ComparableHash>)
- [type Map](<#Map>)
  - [func New\[K comparable, V comparable\]\(\) Map\[K, V\]](<#New>)
  - [func NewCap\[K comparable, V comparable\]\(\_cap int\) Map\[K, V\]](<#NewCap>)
  - [func NewCustom\[K any, V any\]\(\_cap int, eq func\(l K, r K\) bool, hash func\(v K\) uint64\) Map\[K, V\]](<#NewCustom>)
  - [func \(m \*Map\[K, V\]\) Clear\(\)](<#Map[K, V].Clear>)
  - [func \(m \*Map\[K, V\]\) Copy\(\) \*Map\[K, V\]](<#Map[K, V].Copy>)
  - [func \(m \*Map\[K, V\]\) Get\(k K\) \(V, bool\)](<#Map[K, V].Get>)
  - [func \(m \*Map\[K, V\]\) Keys\(\) iter.Seq\[K\]](<#Map[K, V].Keys>)
  - [func \(m \*Map\[K, V\]\) Len\(\) int](<#Map[K, V].Len>)
  - [func \(m \*Map\[K, V\]\) PntrVals\(\) iter.Seq\[\*V\]](<#Map[K, V].PntrVals>)
  - [func \(m \*Map\[K, V\]\) Put\(k K, v V\)](<#Map[K, V].Put>)
  - [func \(m \*Map\[K, V\]\) Remove\(k K\)](<#Map[K, V].Remove>)
  - [func \(m \*Map\[K, V\]\) Vals\(\) iter.Seq\[V\]](<#Map[K, V].Vals>)
  - [func \(m \*Map\[K, V\]\) Zero\(\)](<#Map[K, V].Zero>)


<a name="ComparableEqual"></a>
## func [ComparableEqual](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L58>)

```go
func ComparableEqual[T comparable](l T, r T) bool
```

An equality function that can be passed to [NewCustom](<#NewCustom>) when using a comparable type. If the key type is comparable then you can simply use [New](<#New>) instead of [NewCustom](<#NewCustom>) and this function will be used by default.

<a name="ComparableHash"></a>
## func [ComparableHash](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L65>)

```go
func ComparableHash[T comparable](v T) uint64
```

A hash function that can be passed to [NewCustom](<#NewCustom>) when using a comparable type. If the key type is comparable then you can simply use [New](<#New>) instead of [NewCustom](<#NewCustom>) and this function will be used by default.

<a name="Map"></a>
## type [Map](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L16-L22>)



```go
type Map[K any, V any] struct {
    // contains filtered or unexported fields
}
```

<a name="New"></a>
### func [New](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L99>)

```go
func New[K comparable, V comparable]() Map[K, V]
```

Creates a Map where K is the key type and V is the value type. [ComparableEqual](<#ComparableEqual>) and [ComparableHash](<#ComparableHash>) funcitons will be used by the returned Map. For creating a Map with non\-comparable types or custom hash and equality functions refer to [NewCustom](<#NewCustom>).

<a name="NewCap"></a>
### func [NewCap](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L112>)

```go
func NewCap[K comparable, V comparable](_cap int) Map[K, V]
```

Creates a Map where K is the key type and V is the value type with a capacity of \`\_cap\`. [ComparableEqual](<#ComparableEqual>) and [ComparableHash](<#ComparableHash>) functions will be used by the returned Map. For creating a Map with non\-comparable types or custom hash and equality functions refer to [NewCustom](<#NewCustom>).

<a name="NewCustom"></a>
### func [NewCustom](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L125-L129>)

```go
func NewCustom[K any, V any](_cap int, eq func(l K, r K) bool, hash func(v K) uint64) Map[K, V]
```

Creates a Map where K is the key type and V is the value type with a capacity of \`\_cap\`. The supplied \`eq\` and \`hash\` functions will be used by the Map. If two values are equal the \`hash\` function hash function should return the same hash for both values.

<a name="Map[K, V].Clear"></a>
### func \(\*Map\[K, V\]\) [Clear](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L260>)

```go
func (m *Map[K, V]) Clear()
```

Removes all values from the underlying hash but keeps the maps underlying capacity.

<a name="Map[K, V].Copy"></a>
### func \(\*Map\[K, V\]\) [Copy](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L277>)

```go
func (m *Map[K, V]) Copy() *Map[K, V]
```

Creates a copy of the supplied hash map. All values will be copied using memcpy, meaning a shallow copy will be made of the values.

<a name="Map[K, V].Get"></a>
### func \(\*Map\[K, V\]\) [Get](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L160>)

```go
func (m *Map[K, V]) Get(k K) (V, bool)
```

Gets the value that is related to the supplied key. If the key is found the boolean return value will be true and the value will be returned. If the key is not found the boolean return value will be false and a zero\-initialized value of type V will be returned.

<a name="Map[K, V].Keys"></a>
### func \(\*Map\[K, V\]\) [Keys](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L291>)

```go
func (m *Map[K, V]) Keys() iter.Seq[K]
```

Iterates over all of the keys in the map. Uses the stdlib \`iter\` package so this function can be used in a standard \`for\` loop.

<a name="Map[K, V].Len"></a>
### func \(\*Map\[K, V\]\) [Len](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L140>)

```go
func (m *Map[K, V]) Len() int
```

Returns the number of elements in the hash map. This is different than the maps capacity.

<a name="Map[K, V].PntrVals"></a>
### func \(\*Map\[K, V\]\) [PntrVals](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L322>)

```go
func (m *Map[K, V]) PntrVals() iter.Seq[*V]
```

Iterates over all of the values in the map. Uses the stdlib \`iter\` package so this function can be used in a standard \`for\` loop. The value may be mutated and the results will be seen by the hash map.

<a name="Map[K, V].Put"></a>
### func \(\*Map\[K, V\]\) [Put](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L181>)

```go
func (m *Map[K, V]) Put(k K, v V)
```

Places the supplied key, value pair in the hash map. If the key was already present in the map the old value will be overwritten. The map will resize as necessary.

<a name="Map[K, V].Remove"></a>
### func \(\*Map\[K, V\]\) [Remove](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L232>)

```go
func (m *Map[K, V]) Remove(k K)
```

Removes the supplied key and associated value from the hash map if it is present. If the key is not present in the map then no action will be taken.

<a name="Map[K, V].Vals"></a>
### func \(\*Map\[K, V\]\) [Vals](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L306>)

```go
func (m *Map[K, V]) Vals() iter.Seq[V]
```

Iterates over all of the values in the map. Uses the stdlib \`iter\` package so this function can be used in a standard \`for\` loop.

<a name="Map[K, V].Zero"></a>
### func \(\*Map\[K, V\]\) [Zero](<https://github.com/barbell-math/smoothbrain-hashmap/blob/main/map.go#L270>)

```go
func (m *Map[K, V]) Zero()
```

Removes all values from the underlying hash and resets the maps capacity.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
